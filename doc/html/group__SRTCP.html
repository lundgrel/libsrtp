<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libSRTP: Secure RTCP</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="docs.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libSRTP
   &#160;<span id="projectnumber">0.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Secure RTCP<div class="ingroups"><a class="el" href="group__SRTP.html">Secure RTP</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Secure RTCP functions are used to protect RTCP traffic.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab0d26f6e3805ef252a741df5542be565"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTCP.html#gab0d26f6e3805ef252a741df5542be565">srtp_protect_rtcp</a> (<a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a> ctx, void *rtcp_hdr, int *pkt_octet_len)</td></tr>
<tr class="memdesc:gab0d26f6e3805ef252a741df5542be565"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTCP.html#gab0d26f6e3805ef252a741df5542be565" title="srtp_protect_rtcp() is the Secure RTCP sender-side packet processing function.">srtp_protect_rtcp()</a> is the Secure RTCP sender-side packet processing function.  <a href="group__SRTCP.html#gab0d26f6e3805ef252a741df5542be565">More...</a><br /></td></tr>
<tr class="separator:gab0d26f6e3805ef252a741df5542be565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga656a4ba1c6518e00b9b03f53b8088b99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTCP.html#ga656a4ba1c6518e00b9b03f53b8088b99">srtp_protect_rtcp_mki</a> (<a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a> ctx, void *rtcp_hdr, int *pkt_octet_len, unsigned int use_mki, unsigned int mki_index)</td></tr>
<tr class="memdesc:ga656a4ba1c6518e00b9b03f53b8088b99"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTCP.html#ga656a4ba1c6518e00b9b03f53b8088b99" title="srtp_protect_rtcp_mki() is the Secure RTCP sender-side packet processing function that can utilize mk...">srtp_protect_rtcp_mki()</a> is the Secure RTCP sender-side packet processing function that can utilize mki.  <a href="group__SRTCP.html#ga656a4ba1c6518e00b9b03f53b8088b99">More...</a><br /></td></tr>
<tr class="separator:ga656a4ba1c6518e00b9b03f53b8088b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e8084860c72f1e1bb16fab064664188"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTCP.html#ga7e8084860c72f1e1bb16fab064664188">srtp_unprotect_rtcp</a> (<a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a> ctx, void *srtcp_hdr, int *pkt_octet_len)</td></tr>
<tr class="memdesc:ga7e8084860c72f1e1bb16fab064664188"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTCP.html#ga7e8084860c72f1e1bb16fab064664188" title="srtp_unprotect_rtcp() is the Secure RTCP receiver-side packet processing function.">srtp_unprotect_rtcp()</a> is the Secure RTCP receiver-side packet processing function.  <a href="group__SRTCP.html#ga7e8084860c72f1e1bb16fab064664188">More...</a><br /></td></tr>
<tr class="separator:ga7e8084860c72f1e1bb16fab064664188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7b73c4713a2508924e623320d74c3a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTCP.html#gae7b73c4713a2508924e623320d74c3a4">srtp_unprotect_rtcp_mki</a> (<a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a> ctx, void *srtcp_hdr, int *pkt_octet_len, unsigned int use_mki)</td></tr>
<tr class="memdesc:gae7b73c4713a2508924e623320d74c3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTCP.html#ga7e8084860c72f1e1bb16fab064664188" title="srtp_unprotect_rtcp() is the Secure RTCP receiver-side packet processing function.">srtp_unprotect_rtcp()</a> is the Secure RTCP receiver-side packet processing function.  <a href="group__SRTCP.html#gae7b73c4713a2508924e623320d74c3a4">More...</a><br /></td></tr>
<tr class="separator:gae7b73c4713a2508924e623320d74c3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>RTCP is the control protocol for RTP. libSRTP protects RTCP traffic in much the same way as it does RTP traffic. The function <a class="el" href="group__SRTCP.html#gab0d26f6e3805ef252a741df5542be565" title="srtp_protect_rtcp() is the Secure RTCP sender-side packet processing function.">srtp_protect_rtcp()</a> applies cryptographic protections to outbound RTCP packets, and <a class="el" href="group__SRTCP.html#ga7e8084860c72f1e1bb16fab064664188" title="srtp_unprotect_rtcp() is the Secure RTCP receiver-side packet processing function.">srtp_unprotect_rtcp()</a> verifies the protections on inbound RTCP packets.</p>
<p>A note on the naming convention: <a class="el" href="group__SRTCP.html#gab0d26f6e3805ef252a741df5542be565" title="srtp_protect_rtcp() is the Secure RTCP sender-side packet processing function.">srtp_protect_rtcp()</a> has an srtp_t as its first argument, and thus has &lsquo;srtp_&rsquo; as its prefix. The trailing &lsquo;_rtcp&rsquo; indicates the protocol on which it acts. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab0d26f6e3805ef252a741df5542be565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0d26f6e3805ef252a741df5542be565">&#9670;&nbsp;</a></span>srtp_protect_rtcp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_protect_rtcp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a>&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rtcp_hdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pkt_octet_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function call srtp_protect_rtcp(ctx, rtp_hdr, len_ptr) applies SRTCP protection to the RTCP packet rtcp_hdr (which has length *len_ptr) using the SRTP session context ctx. If srtp_err_status_ok is returned, then rtp_hdr points to the resulting SRTCP packet and *len_ptr is the number of octets in that packet; otherwise, no assumptions should be made about the value of either data elements.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes that it can write the authentication tag into the location in memory immediately following the RTCP packet, and assumes that the RTCP packet is aligned on a 32-bit boundary.</dd>
<dd>
This function assumes that it can write SRTP_MAX_TRAILER_LEN+4 into the location in memory immediately following the RTCP packet. Callers MUST ensure that this much writable memory is available in the buffer that holds the RTCP packet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>is the SRTP context to use in processing the packet.</td></tr>
    <tr><td class="paramname">rtcp_hdr</td><td>is a pointer to the RTCP packet (before the call); after the function returns, it points to the srtp packet.</td></tr>
    <tr><td class="paramname">pkt_octet_len</td><td>is a pointer to the length in octets of the complete RTCP packet (header and body) before the function call, and of the complete SRTCP packet after the call, if srtp_err_status_ok was returned. Otherwise, the value of the data to which it points is undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>srtp_err_status_ok if there were no problems.</li>
<li>[other] if there was a failure in the cryptographic mechanisms. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga656a4ba1c6518e00b9b03f53b8088b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga656a4ba1c6518e00b9b03f53b8088b99">&#9670;&nbsp;</a></span>srtp_protect_rtcp_mki()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_protect_rtcp_mki </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a>&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rtcp_hdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pkt_octet_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>use_mki</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>mki_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function call srtp_protect_rtcp(ctx, rtp_hdr, len_ptr) applies SRTCP protection to the RTCP packet rtcp_hdr (which has length *len_ptr) using the SRTP session context ctx. If srtp_err_status_ok is returned, then rtp_hdr points to the resulting SRTCP packet and *len_ptr is the number of octets in that packet; otherwise, no assumptions should be made about the value of either data elements.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes that it can write the authentication tag into the location in memory immediately following the RTCP packet, and assumes that the RTCP packet is aligned on a 32-bit boundary.</dd>
<dd>
This function assumes that it can write SRTP_MAX_TRAILER_LEN+4 into the location in memory immediately following the RTCP packet. Callers MUST ensure that this much writable memory is available in the buffer that holds the RTCP packet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>is the SRTP context to use in processing the packet.</td></tr>
    <tr><td class="paramname">rtcp_hdr</td><td>is a pointer to the RTCP packet (before the call); after the function returns, it points to the srtp packet.</td></tr>
    <tr><td class="paramname">pkt_octet_len</td><td>is a pointer to the length in octets of the complete RTCP packet (header and body) before the function call, and of the complete SRTCP packet after the call, if srtp_err_status_ok was returned. Otherwise, the value of the data to which it points is undefined.</td></tr>
    <tr><td class="paramname">use_mki</td><td>is a boolean to tell the system if mki is being used. If set to false then will use the first set of session keys. If set to true will use the session keys identified by the mki_index</td></tr>
    <tr><td class="paramname">mki_index</td><td>integer value specifying which set of session keys should be used if use_mki is set to true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>srtp_err_status_ok if there were no problems.</li>
<li>[other] if there was a failure in the cryptographic mechanisms. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7e8084860c72f1e1bb16fab064664188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e8084860c72f1e1bb16fab064664188">&#9670;&nbsp;</a></span>srtp_unprotect_rtcp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_unprotect_rtcp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a>&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>srtcp_hdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pkt_octet_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function call srtp_unprotect_rtcp(ctx, srtp_hdr, len_ptr) verifies the Secure RTCP protection of the SRTCP packet pointed to by srtcp_hdr (which has length *len_ptr), using the SRTP session context ctx. If srtp_err_status_ok is returned, then srtcp_hdr points to the resulting RTCP packet and *len_ptr is the number of octets in that packet; otherwise, no assumptions should be made about the value of either data elements.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes that the SRTCP packet is aligned on a 32-bit boundary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>is a pointer to the srtp_t which applies to the particular packet.</td></tr>
    <tr><td class="paramname">srtcp_hdr</td><td>is a pointer to the header of the SRTCP packet (before the call). After the function returns, it points to the rtp packet if srtp_err_status_ok was returned; otherwise, the value of the data to which it points is undefined.</td></tr>
    <tr><td class="paramname">pkt_octet_len</td><td>is a pointer to the length in octets of the complete SRTCP packet (header and body) before the function call, and of the complete rtp packet after the call, if srtp_err_status_ok was returned. Otherwise, the value of the data to which it points is undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>srtp_err_status_ok if the RTCP packet is valid.</li>
<li>srtp_err_status_auth_fail if the SRTCP packet failed the message authentication check.</li>
<li>srtp_err_status_replay_fail if the SRTCP packet is a replay (e.g. has already been processed and accepted).</li>
<li>[other] if there has been an error in the cryptographic mechanisms. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae7b73c4713a2508924e623320d74c3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7b73c4713a2508924e623320d74c3a4">&#9670;&nbsp;</a></span>srtp_unprotect_rtcp_mki()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_unprotect_rtcp_mki </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a>&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>srtcp_hdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pkt_octet_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>use_mki</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function call srtp_unprotect_rtcp(ctx, srtp_hdr, len_ptr) verifies the Secure RTCP protection of the SRTCP packet pointed to by srtcp_hdr (which has length *len_ptr), using the SRTP session context ctx. If srtp_err_status_ok is returned, then srtcp_hdr points to the resulting RTCP packet and *len_ptr is the number of octets in that packet; otherwise, no assumptions should be made about the value of either data elements.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes that the SRTCP packet is aligned on a 32-bit boundary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>is a pointer to the srtp_t which applies to the particular packet.</td></tr>
    <tr><td class="paramname">srtcp_hdr</td><td>is a pointer to the header of the SRTCP packet (before the call). After the function returns, it points to the rtp packet if srtp_err_status_ok was returned; otherwise, the value of the data to which it points is undefined.</td></tr>
    <tr><td class="paramname">pkt_octet_len</td><td>is a pointer to the length in octets of the complete SRTCP packet (header and body) before the function call, and of the complete rtp packet after the call, if srtp_err_status_ok was returned. Otherwise, the value of the data to which it points is undefined.</td></tr>
    <tr><td class="paramname">use_mki</td><td>is a boolean to tell the system if mki is being used. If set to false then will use the first set of session keys. If set to true will use the session keys identified by the mki_index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>srtp_err_status_ok if the RTCP packet is valid.</li>
<li>srtp_err_status_auth_fail if the SRTCP packet failed the message authentication check.</li>
<li>srtp_err_status_replay_fail if the SRTCP packet is a replay (e.g. has already been processed and accepted).</li>
<li>srtp_err_status_bad_mki if the MKI in the packet is not a known MKI id</li>
<li>[other] if there has been an error in the cryptographic mechanisms. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
