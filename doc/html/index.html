<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libSRTP: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="docs.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libSRTP
   &#160;<span id="projectnumber">0.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">libSRTP Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_S__repos_cisco_libsrtp_README"></a> <a href="https://travis-ci.org/cisco/libsrtp"><img src="https://travis-ci.org/cisco/libsrtp.svg?branch=master" alt="Build Status" style="pointer-events: none;" class="inline"/></a> <a href="https://scan.coverity.com/projects/cisco-libsrtp"><img src="https://scan.coverity.com/projects/14274/badge.svg" alt="Coverity Scan Build Status" style="pointer-events: none;" class="inline"/></a> <a href="https://oss-fuzz-build-logs.storage.googleapis.com/index.html#libsrtp"><img src="https://oss-fuzz-build-logs.storage.googleapis.com/badges/systemd.svg" alt="OSS-Fuzz Status" style="pointer-events: none;" class="inline"/></a></p>
<p><a class="anchor" id="introduction-to-libsrtp"></a> </p>
<h1><a class="anchor" id="autotoc_md0"></a>
Introduction to libSRTP</h1>
<p>This package provides an implementation of the Secure Real-time Transport Protocol (SRTP), the Universal Security Transform (UST), and a supporting cryptographic kernel. The SRTP API is documented in <a class="el" href="srtp_8h_source.html">include/srtp.h</a>, and the library is in libsrtp2.a (after compilation).</p>
<p>This document describes libSRTP, the Open Source Secure RTP library from Cisco Systems, Inc. RTP is the Real-time Transport Protocol, an IETF standard for the transport of real-time data such as telephony, audio, and video, defined by <a href="https://tools.ietf.org/html/rfc3550">RFC 3550</a>. Secure RTP (SRTP) is an RTP profile for providing confidentiality to RTP data and authentication to the RTP header and payload. SRTP is an IETF Standard, defined in <a href="https://tools.ietf.org/html/rfc3711">RFC 3711</a>, and was developed in the IETF Audio/Video Transport (AVT) Working Group. This library supports all of the mandatory features of SRTP, but not all of the optional features. See the <a href="#supported-features">Supported Features</a> section for more detailed information.</p>
<p>This document is also used to generate the documentation files in the /doc/ folder where a more detailed reference to the libSRTP API and related functions can be created (requires installing doxygen.). The reference material is created automatically from comments embedded in some of the C header files. The documentation is organized into modules in order to improve its clarity. These modules do not directly correspond to files. An underlying cryptographic kernel provides much of the basic functionality of libSRTP but is mostly undocumented because it does its work behind the scenes.</p>
<hr  />
<p><a class="anchor" id="contact-us"></a> </p>
<h1><a class="anchor" id="autotoc_md2"></a>
Contact Us</h1>
<ul>
<li><a href="#" onclick="location.href='mai'+'lto:'+'lib'+'sr'+'tp@'+'li'+'sts'+'.p'+'ack'+'et'+'ize'+'r.'+'com'; return false;">libsrtp@lists.packetizer.com</a> general mailing list for news / announcements / discussions. This is an open list, see <a href="https://lists.packetizer.com/mailman/listinfo/libsrtp">https://lists.packetizer.com/mailman/listinfo/libsrtp</a> for singing up.</li>
<li><a href="#" onclick="location.href='mai'+'lto:'+'lib'+'sr'+'tp-'+'se'+'cur'+'it'+'y@l'+'is'+'ts.'+'pa'+'cke'+'ti'+'zer'+'.c'+'om'; return false;">libsrtp-security@lists.packetizer.com</a> for disclosing security issues to the libsrtp maintenance team. This is a closed list but anyone can send to it.</li>
</ul>
<hr  />
<p><a class="anchor" id="contents"></a> </p>
<h2><a class="anchor" id="autotoc_md4"></a>
Contents</h2>
<ul>
<li><a href="#introduction-to-libsrtp">Introduction to libSRTP</a></li>
<li><a href="#contact-us">Contact Us</a><ul>
<li><a href="#contents">Contents</a></li>
</ul>
</li>
<li><a href="#license-and-disclaimer">License and Disclaimer</a></li>
<li><a href="#libsrtp-overview">libSRTP Overview</a><ul>
<li><a href="#secure-rtp-background">Secure RTP Background</a></li>
<li><a href="#supported-features">Supported Features</a></li>
<li><a href="#implementation-notes">Implementation Notes</a></li>
</ul>
</li>
<li><a href="#installing-and-building-libsrtp">Installing and Building libSRTP</a><ul>
<li><a href="#changing-build-configuration">Changing Build Configuration</a></li>
<li><a href="#using-visual-studio">Using Visual Studio</a></li>
</ul>
</li>
<li><a href="#applications">Applications</a><ul>
<li><a href="#example-code">Example Code</a></li>
</ul>
</li>
<li><a href="#credits">Credits</a></li>
<li><a href="#references">References</a></li>
</ul>
<hr  />
<p><a class="anchor" id="license-and-disclaimer"></a> </p>
<h1><a class="anchor" id="autotoc_md6"></a>
License and Disclaimer</h1>
<p>libSRTP is distributed under the following license, which is included in the source code distribution. It is reproduced in the manual in case you got the library from another source.</p>
<blockquote class="doxtable">
<p>Copyright (c) 2001-2017 Cisco Systems, Inc. All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the Cisco Systems, Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</li>
</ul>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md7"></a>
&lt;/blockquote&gt;</h2>
<p><a class="anchor" id="libsrtp-overview"></a> </p>
<h1><a class="anchor" id="autotoc_md8"></a>
libSRTP Overview</h1>
<p>libSRTP provides functions for protecting RTP and RTCP. RTP packets can be encrypted and authenticated (using the <code><a class="el" href="group__SRTP.html#gaed717c57385c7bf1f4369c27ac2742d2" title="srtp_protect() is the Secure RTP sender-side packet processing function.">srtp_protect()</a></code> function), turning them into SRTP packets. Similarly, SRTP packets can be decrypted and have their authentication verified (using the <code><a class="el" href="group__SRTP.html#gad4c3669a5b8cb19f3dfbdbefb90ee94a" title="srtp_unprotect() is the Secure RTP receiver-side packet processing function.">srtp_unprotect()</a></code> function), turning them into RTP packets. Similar functions apply security to RTCP packets.</p>
<p>The typedef <code>srtp_stream_t</code> points to a structure holding all of the state associated with an SRTP stream, including the keys and parameters for cipher and message authentication functions and the anti-replay data. A particular <code>srtp_stream_t</code> holds the information needed to protect a particular RTP and RTCP stream. This datatype is intentionally opaque in order to better seperate the libSRTP API from its implementation.</p>
<p>Within an SRTP session, there can be multiple streams, each originating from a particular sender. Each source uses a distinct stream context to protect the RTP and RTCP stream that it is originating. The typedef <code>srtp_t</code> points to a structure holding all of the state associated with an SRTP session. There can be multiple stream contexts associated with a single <code>srtp_t</code>. A stream context cannot exist indepent from an <code>srtp_t</code>, though of course an <code>srtp_t</code> can be created that contains only a single stream context. A device participating in an SRTP session must have a stream context for each source in that session, so that it can process the data that it receives from each sender.</p>
<p>In libSRTP, a session is created using the function <code><a class="el" href="group__SRTP.html#gac7874ac09c2a1abf0d893566f933f477" title="srtp_create() allocates and initializes an SRTP session.">srtp_create()</a></code>. The policy to be implemented in the session is passed into this function as an <code><a class="el" href="structsrtp__policy__t.html" title="represents the policy for an SRTP session.">srtp_policy_t</a></code> structure. A single one of these structures describes the policy of a single stream. These structures can also be linked together to form an entire session policy. A linked list of <code><a class="el" href="structsrtp__policy__t.html" title="represents the policy for an SRTP session.">srtp_policy_t</a></code> structures is equivalent to a session policy. In such a policy, we refer to a single <code><a class="el" href="structsrtp__policy__t.html" title="represents the policy for an SRTP session.">srtp_policy_t</a></code> as an <em>element</em>.</p>
<p>An <code><a class="el" href="structsrtp__policy__t.html" title="represents the policy for an SRTP session.">srtp_policy_t</a></code> structure contains two <code><a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream.">srtp_crypto_policy_t</a></code> structures that describe the cryptograhic policies for RTP and RTCP, as well as the SRTP master key and the SSRC value. The SSRC describes what to protect (e.g. which stream), and the <code><a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream.">srtp_crypto_policy_t</a></code> structures describe how to protect it. The key is contained in a policy element because it simplifies the interface to the library. In many cases, it is desirable to use the same cryptographic policies across all of the streams in a session, but to use a distinct key for each stream. A <code><a class="el" href="structsrtp__crypto__policy__t.html" title="srtp_crypto_policy_t describes a particular crypto policy that can be applied to an SRTP stream.">srtp_crypto_policy_t</a></code> structure can be initialized by using either the <code><a class="el" href="group__SRTP.html#ga5283f0bcdd44be2ec314077f74d831b0" title="srtp_crypto_policy_set_rtp_default() sets a crypto policy structure to the SRTP default policy for RT...">srtp_crypto_policy_set_rtp_default()</a></code> or <code><a class="el" href="group__SRTP.html#ga265e7d332804da1f823d68042192bc45" title="srtp_crypto_policy_set_rtcp_default() sets a crypto policy structure to the SRTP default policy for R...">srtp_crypto_policy_set_rtcp_default()</a></code> functions, which set a crypto policy structure to the default policies for RTP and RTCP protection, respectively.</p>
<hr  />
<p><a class="anchor" id="secure-rtp-background"></a> </p>
<h2><a class="anchor" id="autotoc_md10"></a>
Secure RTP Background</h2>
<p>In this section we review SRTP and introduce some terms that are used in libSRTP. An RTP session is defined by a pair of destination transport addresses, that is, a network address plus a pair of UDP ports for RTP and RTCP. RTCP, the RTP control protocol, is used to coordinate between the participants in an RTP session, e.g. to provide feedback from receivers to senders. An <em>SRTP session</em> is similarly defined; it is just an RTP session for which the SRTP profile is being used. An SRTP session consists of the traffic sent to the SRTP or SRTCP destination transport addresses. Each participant in a session is identified by a synchronization source (SSRC) identifier. Some participants may not send any SRTP traffic; they are called receivers, even though they send out SRTCP traffic, such as receiver reports.</p>
<p>RTP allows multiple sources to send RTP and RTCP traffic during the same session. The synchronization source identifier (SSRC) is used to distinguish these sources. In libSRTP, we call the SRTP and SRTCP traffic from a particular source a <em>stream</em>. Each stream has its own SSRC, sequence number, rollover counter, and other data. A particular choice of options, cryptographic mechanisms, and keys is called a <em>policy</em>. Each stream within a session can have a distinct policy applied to it. A session policy is a collection of stream policies.</p>
<p>A single policy can be used for all of the streams in a given session, though the case in which a single <em>key</em> is shared across multiple streams requires care. When key sharing is used, the SSRC values that identify the streams <b>must</b> be distinct. This requirement can be enforced by using the convention that each SRTP and SRTCP key is used for encryption by only a single sender. In other words, the key is shared only across streams that originate from a particular device (of course, other SRTP participants will need to use the key for decryption). libSRTP supports this enforcement by detecting the case in which a key is used for both inbound and outbound data.</p>
<hr  />
<p><a class="anchor" id="supported-features"></a> </p>
<h2><a class="anchor" id="autotoc_md12"></a>
Supported Features</h2>
<p>This library supports all of the mandatory-to-implement features of SRTP (as defined in <a href="https://tools.ietf.org/html/rfc3711">RFC 3711</a>). Some of these features can be selected (or de-selected) at run time by setting an appropriate policy; this is done using the structure <code><a class="el" href="structsrtp__policy__t.html" title="represents the policy for an SRTP session.">srtp_policy_t</a></code>. Some other behaviors of the protocol can be adapted by defining an approriate event handler for the exceptional events; see the SRTPevents section in the generated documentation.</p>
<p>Some options that are described in the SRTP specification are not supported. This includes</p>
<ul>
<li>key derivation rates other than zero,</li>
<li>the cipher F8,</li>
<li>the use of the packet index to select between master keys.</li>
</ul>
<p>The user should be aware that it is possible to misuse this libary, and that the result may be that the security level it provides is inadequate. If you are implementing a feature using this library, you will want to read the Security Considerations section of <a href="https://tools.ietf.org/html/rfc3711#section-9">RFC 3711</a>. In addition, it is important that you read and understand the terms outlined in the <a href="#license-and-disclaimer">License and Disclaimer</a> section.</p>
<hr  />
<p><a class="anchor" id="implementation-notes"></a> </p>
<h2><a class="anchor" id="autotoc_md14"></a>
Implementation Notes</h2>
<ul>
<li>The <code><a class="el" href="group__SRTP.html#gaed717c57385c7bf1f4369c27ac2742d2" title="srtp_protect() is the Secure RTP sender-side packet processing function.">srtp_protect()</a></code> function assumes that the buffer holding the rtp packet has enough storage allocated that the authentication tag can be written to the end of that packet. If this assumption is not valid, memory corruption will ensue.</li>
<li>Automated tests for the crypto functions are provided through the <code>cipher_type_self_test()</code> and <code>auth_type_self_test()</code> functions. These functions should be used to test each port of this code to a new platform.</li>
<li>Replay protection is contained in the crypto engine, and tests for it are provided.</li>
<li>This implementation provides calls to initialize, protect, and unprotect RTP packets, and makes as few as possible assumptions about how these functions will be called. For example, the caller is not expected to provide packets in order (though if they're called more than 65k out of sequence, synchronization will be lost).</li>
<li>The sequence number in the rtp packet is used as the low 16 bits of the sender's local packet index. Note that RTP will start its sequence number in a random place, and the SRTP layer just jumps forward to that number at its first invocation. An earlier version of this library used initial sequence numbers that are less than 32,768; this trick is no longer required as the <code>rdbx_estimate_index(...)</code> function has been made smarter.</li>
<li>The replay window for (S)RTCP is hardcoded to 128 bits in length.</li>
</ul>
<hr  />
<p><a class="anchor" id="installing-and-building-libsrtp"></a> </p>
<h1><a class="anchor" id="autotoc_md16"></a>
Installing and Building libSRTP</h1>
<p>To install libSRTP, download the latest release of the distribution from <a href="https://github.com/cisco/libsrtp/releases">https://github.com/cisco/libsrtp/releases</a>. You probably want to get the most recent release. Unpack the distribution and extract the source files; the directory into which the source files will go is named <code>libsrtp-A-B-C</code> where <code>A</code> is the version number, <code>B</code> is the major release number and <code>C</code> is the minor release number.</p>
<p>libSRTP uses the GNU <code>autoconf</code> and <code>make</code> utilities (BSD make will not work; if both versions of make are on your platform, you can invoke GNU make as <code>gmake</code>.). In the <code>libsrtp</code> directory, run the configure script and then make:</p>
<div class="fragment"><div class="line">./configure [ options ]</div>
<div class="line">make</div>
</div><!-- fragment --><p>The configure script accepts the following options:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Option   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--help -h   </td><td class="markdownTableBodyNone">Display help    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--enable-debug-logging   </td><td class="markdownTableBodyNone">Enable debug logging in all modules    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--enable-log-stdout   </td><td class="markdownTableBodyNone">Enable logging to stdout    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--enable-openssl   </td><td class="markdownTableBodyNone">Enable OpenSSL crypto engine    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--enable-openssl-kdf   </td><td class="markdownTableBodyNone">Enable OpenSSL KDF algorithm    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">--with-log-file   </td><td class="markdownTableBodyNone">Use file for logging    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">--with-openssl-dir   </td><td class="markdownTableBodyNone">Location of OpenSSL installation   </td></tr>
</table>
<p>By default there is no log output, logging can be enabled to be output to stdout or a given file using the configure options.</p>
<p>This package has been tested on the following platforms: Mac OS X (powerpc-apple-darwin1.4), Cygwin (i686-pc-cygwin), Solaris (sparc-sun-solaris2.6), RedHat Linux 7.1 and 9 (i686-pc-linux), and OpenBSD (sparc-unknown-openbsd2.7).</p>
<hr  />
<p><a class="anchor" id="changing-build-configuration"></a> </p>
<h2><a class="anchor" id="autotoc_md18"></a>
Changing Build Configuration</h2>
<p>To build the <code>./configure</code> script mentioned above, libSRTP relies on the <a href="https://www.gnu.org/software/automake/">automake</a> toolchain. Since <code>./configure</code> is built from <code>configure.in</code> by automake, if you make changes in how <code>./configure</code> works (e.g., to add a new library dependency), you will need to rebuild <code>./configure</code> and commit the updated version. In addition to automake itself, you will need to have the <code>pkgconfig</code> tools installed as well.</p>
<p>For example, on macOS:</p>
<div class="fragment"><div class="line">brew install automake pkgconfig</div>
<div class="line"># Edit configure.in</div>
<div class="line">autoremake -ivf</div>
</div><!-- fragment --><hr  />
<p> <a class="anchor" id="using-visual-studio"></a> </p>
<h2><a class="anchor" id="autotoc_md20"></a>
Using Visual Studio</h2>
<p>On Windows one can use Visual Studio via CMake. CMake can be downloaded here: <a href="https://cmake.org/">https://cmake.org/</a> . To create Visual Studio build files, for example run the following commands:</p>
<div class="fragment"><div class="line"># Create build subdirectory</div>
<div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line"> </div>
<div class="line"># Make project files</div>
<div class="line">cmake .. -G &quot;Visual Studio 15 2017&quot;</div>
<div class="line"> </div>
<div class="line"># Or for 64 bit project files</div>
<div class="line">cmake .. -G &quot;Visual Studio 15 2017 Win64&quot;</div>
</div><!-- fragment --><hr  />
<p> <a class="anchor" id="using-meson"></a> </p>
<h2><a class="anchor" id="autotoc_md22"></a>
Using Meson</h2>
<p>On all platforms including Windows, one can build using <a href="https://mesonbuild.org">Meson</a>. Steps to download Meson are here: <a href="https://mesonbuild.com/Getting-meson.html">https://mesonbuild.com/Getting-meson.html</a></p>
<p>To build with Meson, you can do something like:</p>
<div class="fragment"><div class="line"># Setup the build subdirectory</div>
<div class="line">meson setup --prefix=/path/to/prefix builddir</div>
<div class="line"> </div>
<div class="line"># Build the project</div>
<div class="line">meson compile -C builddir</div>
<div class="line"> </div>
<div class="line"># Run tests</div>
<div class="line">meson test -C builddir</div>
<div class="line"> </div>
<div class="line"># Optionally, install</div>
<div class="line">meson install -C builddir</div>
</div><!-- fragment --><p>To build with Visual Studio, run the above commands from inside a Visual Studio command prompt, or run <code>vcvarsall.bat</code> with the appropriate arguments inside a Command Prompt.</p>
<p>Note that you can also replace the above commands with the appropriate <code>ninja</code> targets: <code>ninja -C build</code>, <code>ninja -C build test</code>, <code>ninja -C build install</code>.</p>
<hr  />
<p><a class="anchor" id="applications"></a> </p>
<h1><a class="anchor" id="autotoc_md24"></a>
Applications</h1>
<p>Several test drivers and a simple and portable srtp application are included in the <code>test/</code> subdirectory.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Test driver   </th><th class="markdownTableHeadNone">Function tested    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">kernel_driver   </td><td class="markdownTableBodyNone">crypto kernel (ciphers, auth funcs, rng)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">srtp_driver   </td><td class="markdownTableBodyNone">srtp in-memory tests (does not use the network)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">rdbx_driver   </td><td class="markdownTableBodyNone">rdbx (extended replay database)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">roc_driver   </td><td class="markdownTableBodyNone">extended sequence number functions    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">replay_driver   </td><td class="markdownTableBodyNone">replay database    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cipher_driver   </td><td class="markdownTableBodyNone">ciphers    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">auth_driver   </td><td class="markdownTableBodyNone">hash functions   </td></tr>
</table>
<p>The app <code>rtpw</code> is a simple rtp application which reads words from <code>/usr/dict/words</code> and then sends them out one at a time using [s]rtp. Manual srtp keying uses the -k option; automated key management using gdoi will be added later.</p>
<p>usage: </p><div class="fragment"><div class="line">rtpw [[-d &lt;debug&gt;]* [-k|b &lt;key&gt; [-a][-e &lt;key size&gt;][-g]] [-s | -r] dest_ip dest_port] | [-l]</div>
</div><!-- fragment --><p>Either the -s (sender) or -r (receiver) option must be chosen. The values <code>dest_ip</code>, <code>dest_port</code> are the IP address and UDP port to which the dictionary will be sent, respectively.</p>
<p>The options are:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Option   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-s   </td><td class="markdownTableBodyNone">(S)RTP sender - causes app to send words    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">-r   </td><td class="markdownTableBodyNone">(S)RTP receive - causes app to receive words    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-k &lt;key&gt;   </td><td class="markdownTableBodyNone">use SRTP master key &lt;key&gt;, where the key is a hexadecimal (without the leading "0x")    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">-b &lt;key&gt;   </td><td class="markdownTableBodyNone">same as -k but with base64 encoded key    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-e &lt;keysize&gt;   </td><td class="markdownTableBodyNone">encrypt/decrypt (for data confidentiality) (requires use of -k option as well) (use 128, 192, or 256 for keysize)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">-g   </td><td class="markdownTableBodyNone">use AES-GCM mode (must be used with -e)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-a   </td><td class="markdownTableBodyNone">message authentication (requires use of -k option as well)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">-l   </td><td class="markdownTableBodyNone">list the available debug modules    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">-d &lt;debug&gt;   </td><td class="markdownTableBodyNone">turn on debugging for module &lt;debug&gt;   </td></tr>
</table>
<p>In order to get random 30-byte values for use as key/salt pairs , you can use the following bash function to format the output of <code>/dev/random</code> (where that device is available).</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> randhex() {</div>
<div class="line">   cat /dev/random | od --read-bytes=32 --width=32 -x | awk <span class="stringliteral">&#39;{ print $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14 $15 $16 }&#39;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>An example of an SRTP session using two rtpw programs follows:</p>
<div class="fragment"><div class="line">set k=c1eec3717da76195bb878578790af71c4ee9f859e197a414a78d5abc7451</div>
<div class="line"> </div>
<div class="line">[sh1]$ test/rtpw -s -k $k -e 128 -a 0.0.0.0 9999</div>
<div class="line">Security services: confidentiality message authentication</div>
<div class="line">set master key/salt to C1EEC3717DA76195BB878578790AF71C/4EE9F859E197A414A78D5ABC7451</div>
<div class="line">setting SSRC to 2078917053</div>
<div class="line">sending word: A</div>
<div class="line">sending word: a</div>
<div class="line">sending word: aa</div>
<div class="line">sending word: aal</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">[sh2]$ test/rtpw -r -k $k -e 128 -a 0.0.0.0 9999</div>
<div class="line">security services: confidentiality message authentication</div>
<div class="line">set master key/salt to C1EEC3717DA76195BB878578790AF71C/4EE9F859E197A414A78D5ABC7451</div>
<div class="line">19 octets received from SSRC 2078917053 word: A</div>
<div class="line">19 octets received from SSRC 2078917053 word: a</div>
<div class="line">20 octets received from SSRC 2078917053 word: aa</div>
<div class="line">21 octets received from SSRC 2078917053 word: aal</div>
<div class="line">...</div>
</div><!-- fragment --><hr  />
<p><a class="anchor" id="example-code"></a> </p>
<h2><a class="anchor" id="autotoc_md26"></a>
Example Code</h2>
<p>This section provides a simple example of how to use libSRTP. The example code lacks error checking, but is functional. Here we assume that the value ssrc is already set to describe the SSRC of the stream that we are sending, and that the functions <code>get_rtp_packet()</code> and <code>send_srtp_packet()</code> are available to us. The former puts an RTP packet into the buffer and returns the number of octets written to that buffer. The latter sends the RTP packet in the buffer, given the length as its second argument.</p>
<div class="fragment"><div class="line"><a class="code" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a> session;</div>
<div class="line"><a class="code" href="structsrtp__policy__t.html">srtp_policy_t</a> policy;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set key to predetermined value</span></div>
<div class="line">uint8_t key[30] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,</div>
<div class="line">                   0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,</div>
<div class="line">                   0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,</div>
<div class="line">                   0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// initialize libSRTP</span></div>
<div class="line"><a class="code" href="group__SRTP.html#gaf7be4aa17ae3ac2527bf8a499d13739c">srtp_init</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// default policy values</span></div>
<div class="line">memset(&amp;policy, 0x0, <span class="keyword">sizeof</span>(<a class="code" href="structsrtp__policy__t.html">srtp_policy_t</a>));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// set policy to describe a policy for an SRTP stream</span></div>
<div class="line"><a class="code" href="group__SRTP.html#ga5283f0bcdd44be2ec314077f74d831b0">srtp_crypto_policy_set_rtp_default</a>(&amp;policy.<a class="code" href="structsrtp__policy__t.html#a7a2bce58e854e44e6d449ec7141b33e2">rtp</a>);</div>
<div class="line"><a class="code" href="group__SRTP.html#ga265e7d332804da1f823d68042192bc45">srtp_crypto_policy_set_rtcp_default</a>(&amp;policy.<a class="code" href="structsrtp__policy__t.html#aa1847e6734f709f86e79d0600bc4f24f">rtcp</a>);</div>
<div class="line">policy.<a class="code" href="structsrtp__policy__t.html#ac75ef5b52a26ff6a3fe22047ba16add5">ssrc</a> = ssrc;</div>
<div class="line">policy.<a class="code" href="structsrtp__policy__t.html#aaad28f32901e3c4c778e87ce5e6de753">key</a>  = key;</div>
<div class="line">policy.<a class="code" href="structsrtp__policy__t.html#a6e0d2dbb6d41eedb0eb6597f9b7073a8">next</a> = NULL;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// allocate and initialize the SRTP session</span></div>
<div class="line"><a class="code" href="group__SRTP.html#gac7874ac09c2a1abf0d893566f933f477">srtp_create</a>(&amp;session, &amp;policy);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// main loop: get rtp packets, send srtp packets</span></div>
<div class="line"><span class="keywordflow">while</span> (1) {</div>
<div class="line">  <span class="keywordtype">char</span> rtp_buffer[2048];</div>
<div class="line">  <span class="keywordtype">unsigned</span> len;</div>
<div class="line"> </div>
<div class="line">  len = get_rtp_packet(rtp_buffer);</div>
<div class="line">  <a class="code" href="group__SRTP.html#gaed717c57385c7bf1f4369c27ac2742d2">srtp_protect</a>(session, rtp_buffer, &amp;len);</div>
<div class="line">  send_srtp_packet(rtp_buffer, len);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__SRTP_html_ga1c404a756add908efb805d6b729994d0"><div class="ttname"><a href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a></div><div class="ttdeci">srtp_ctx_t * srtp_t</div><div class="ttdoc">An srtp_t points to an SRTP session structure.</div><div class="ttdef"><b>Definition:</b> srtp.h:351</div></div>
<div class="ttc" id="agroup__SRTP_html_ga265e7d332804da1f823d68042192bc45"><div class="ttname"><a href="group__SRTP.html#ga265e7d332804da1f823d68042192bc45">srtp_crypto_policy_set_rtcp_default</a></div><div class="ttdeci">void srtp_crypto_policy_set_rtcp_default(srtp_crypto_policy_t *p)</div><div class="ttdoc">srtp_crypto_policy_set_rtcp_default() sets a crypto policy structure to the SRTP default policy for R...</div></div>
<div class="ttc" id="agroup__SRTP_html_ga5283f0bcdd44be2ec314077f74d831b0"><div class="ttname"><a href="group__SRTP.html#ga5283f0bcdd44be2ec314077f74d831b0">srtp_crypto_policy_set_rtp_default</a></div><div class="ttdeci">void srtp_crypto_policy_set_rtp_default(srtp_crypto_policy_t *p)</div><div class="ttdoc">srtp_crypto_policy_set_rtp_default() sets a crypto policy structure to the SRTP default policy for RT...</div></div>
<div class="ttc" id="agroup__SRTP_html_gac7874ac09c2a1abf0d893566f933f477"><div class="ttname"><a href="group__SRTP.html#gac7874ac09c2a1abf0d893566f933f477">srtp_create</a></div><div class="ttdeci">srtp_err_status_t srtp_create(srtp_t *session, const srtp_policy_t *policy)</div><div class="ttdoc">srtp_create() allocates and initializes an SRTP session.</div></div>
<div class="ttc" id="agroup__SRTP_html_gaed717c57385c7bf1f4369c27ac2742d2"><div class="ttname"><a href="group__SRTP.html#gaed717c57385c7bf1f4369c27ac2742d2">srtp_protect</a></div><div class="ttdeci">srtp_err_status_t srtp_protect(srtp_t ctx, void *rtp_hdr, int *len_ptr)</div><div class="ttdoc">srtp_protect() is the Secure RTP sender-side packet processing function.</div></div>
<div class="ttc" id="agroup__SRTP_html_gaf7be4aa17ae3ac2527bf8a499d13739c"><div class="ttname"><a href="group__SRTP.html#gaf7be4aa17ae3ac2527bf8a499d13739c">srtp_init</a></div><div class="ttdeci">srtp_err_status_t srtp_init(void)</div><div class="ttdoc">srtp_init() initializes the srtp library.</div></div>
<div class="ttc" id="astructsrtp__policy__t_html"><div class="ttname"><a href="structsrtp__policy__t.html">srtp_policy_t</a></div><div class="ttdoc">represents the policy for an SRTP session.</div><div class="ttdef"><b>Definition:</b> srtp.h:311</div></div>
<div class="ttc" id="astructsrtp__policy__t_html_a6e0d2dbb6d41eedb0eb6597f9b7073a8"><div class="ttname"><a href="structsrtp__policy__t.html#a6e0d2dbb6d41eedb0eb6597f9b7073a8">srtp_policy_t::next</a></div><div class="ttdeci">struct srtp_policy_t * next</div><div class="ttdef"><b>Definition:</b> srtp.h:336</div></div>
<div class="ttc" id="astructsrtp__policy__t_html_a7a2bce58e854e44e6d449ec7141b33e2"><div class="ttname"><a href="structsrtp__policy__t.html#a7a2bce58e854e44e6d449ec7141b33e2">srtp_policy_t::rtp</a></div><div class="ttdeci">srtp_crypto_policy_t rtp</div><div class="ttdef"><b>Definition:</b> srtp.h:316</div></div>
<div class="ttc" id="astructsrtp__policy__t_html_aa1847e6734f709f86e79d0600bc4f24f"><div class="ttname"><a href="structsrtp__policy__t.html#aa1847e6734f709f86e79d0600bc4f24f">srtp_policy_t::rtcp</a></div><div class="ttdeci">srtp_crypto_policy_t rtcp</div><div class="ttdef"><b>Definition:</b> srtp.h:317</div></div>
<div class="ttc" id="astructsrtp__policy__t_html_aaad28f32901e3c4c778e87ce5e6de753"><div class="ttname"><a href="structsrtp__policy__t.html#aaad28f32901e3c4c778e87ce5e6de753">srtp_policy_t::key</a></div><div class="ttdeci">unsigned char * key</div><div class="ttdef"><b>Definition:</b> srtp.h:318</div></div>
<div class="ttc" id="astructsrtp__policy__t_html_ac75ef5b52a26ff6a3fe22047ba16add5"><div class="ttname"><a href="structsrtp__policy__t.html#ac75ef5b52a26ff6a3fe22047ba16add5">srtp_policy_t::ssrc</a></div><div class="ttdeci">srtp_ssrc_t ssrc</div><div class="ttdef"><b>Definition:</b> srtp.h:312</div></div>
</div><!-- fragment --><hr  />
<p><a class="anchor" id="credits"></a> </p>
<h1><a class="anchor" id="autotoc_md28"></a>
Credits</h1>
<p>The original implementation and documentation of libSRTP was written by David McGrew of Cisco Systems, Inc. in order to promote the use, understanding, and interoperability of Secure RTP. Michael Jerris contributed support for building under MSVC. Andris Pavenis contributed many important fixes. Brian West contributed changes to enable dynamic linking. Yves Shumann reported documentation bugs. Randell Jesup contributed a working SRTCP implementation and other fixes. Steve Underwood contributed x86_64 portability changes. We also give thanks to Fredrik Thulin, Brian Weis, Mark Baugher, Jeff Chan, Bill Simon, Douglas Smith, Bill May, Richard Preistley, Joe Tardo and others for contributions, comments, and corrections.</p>
<p>This reference material, when applicable, in this documenation was generated using the doxygen utility for automatic documentation of source code.</p>
<p>Copyright 2001-2005 by David A. McGrew, Cisco Systems, Inc.</p>
<hr  />
<p><a class="anchor" id="references"></a> </p>
<h1><a class="anchor" id="autotoc_md30"></a>
References</h1>
<p>SRTP and ICM References September, 2005</p>
<p>Secure RTP is defined in <a href="https://tools.ietf.org/html/rfc3711">RFC 3711</a>. The counter mode definition is in <a href="https://tools.ietf.org/html/rfc3711#section-4.1.1">Section 4.1.1</a>.</p>
<p>SHA-1 is defined in <a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">FIPS PUB 180-4</a>.</p>
<p>HMAC is defined in <a href="https://tools.ietf.org/html/rfc2104">RFC 2104</a> and HMAC-SHA1 test vectors are available in <a href="https://tools.ietf.org/html/rfc2202#section-3">RFC 2202</a>.</p>
<p>AES-GCM usage in SRTP is defined in <a href="https://tools.ietf.org/html/rfc7714">RFC 7714</a> </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
